# 那些最动人的电影情节

## 微盟商家一面复盘

业务问题

1. 印象最深刻的一个项目（应该多讲讲的...）

技术问题：

1. java集合：hashMap原理，知道哪些线程安全的map，sychronize

2. Spring：bean生命周期，aop/ioc，父子容器

   https://www.cnblogs.com/tuyang1129/p/12866484.html

   

   父子容器：

   https://www.zhihu.com/question/39814046/answer/1993816768 父子容器

   https://blog.csdn.net/likun557/article/details/105608851父子容器

   https://zhuanlan.zhihu.com/p/361723096 阿里一面：说说对Spring和SpringMvc父子容器的理解？

   Spring是父容器，SpringMVC是其子容器，并且在Spring父容器中注册的Bean对于SpringMVC容器中是可见的，而在SpringMVC容器中注册的Bean对于Spring父容器中是不可见的，也就是子容器可以看见父容器中的注册的Bean，反之就不行。

   Spring父容器负责所有其他非@Controller注解的Bean的注册，而SpringMVC只负责@Controller注解的Bean的注册，使得他们各负其责、明确边界。配置方式如下

3. mysql：myisam和innodb的区别，索引，b+树和哈希索引

   1事务 2外键 3索引结构 4锁

4. redis：用过哪些数据结构，跳表

   string set list hash zset  geo  bitmap 

5. kafka：零拷贝

6. jvm：JMM，CMS和G1，双亲委派，类加载器

   垃圾回收https://www.jianshu.com/p/671495682e46

   《深入理解jvm虚拟机》

介绍下微盟

1. 业务：为商家提供公众号/小程序入驻之类的，类似于有赞
2. 技术：常用的组件都有，分团队作战



## 太保保险团单初面复盘

自我介绍，需要有些侧重点：项目角色/使用的技术

技术问题

1. 小贝知考程序设计上遇到的问题？

2. 怎么做慢查询的优化？

3. 怎么发现的慢查询问题？

4. 有没有优化索引？怎么优化的？

5. redis是什么？为什么用？底层原理是什么样的？

   回答：单线程+io多路复用+内存+独特的数据结构优化机制

   ```
   ### 操作系统视角的IO多路复用
   
   select的缺陷
         高并发的核心解决方案是1个线程处理所有连接的“等待消息准备好”，这一点上epoll和select是无争议的。但select预估错误了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。select的使用方法是这样的：
         返回的活跃连接 ==select（全部待监控的连接）。
         什么时候会调用select方法呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，调用select在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被“频繁”二字所放大。它有效率损失吗？显而易见，全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。被放大后就会发现，处理并发上万个连接时，select就完全力不从心了。
   
   要深刻理解epoll，首先得了解epoll的三大关键要素：mmap、红黑树、链表。
   
   epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。
   
     红黑树将存储epoll所监听的套接字，epoll在实现上采用红黑树去存储所有套接字，当添加或者删除一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。
   
   一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用epoll_wait时，epoll_wait只需要检查rdlist双向链表中是否有存在注册的事件，效率非常可观。这里也需要将发生了的事件复制到用户态内存中即可。
   
   总而言之：
   epoll用mmp方式映射了一块对用户态和内核态都可见的物理内存
   用红黑树存储所有连接的socket
   用双向链表存储所有就绪的socket，拷贝只需要用这个list中的就行
   ```

   

6. redis为什么比mysql快？

7. 说一下SM-2算法

8. jdk1.8的hashmap，怎么扩容

9. kafka的使用和原理？mq的选型？消息的顺序如何保证？消息写入多少个分区副本

介绍下太保

1. 太平洋寿险公司，做保险中团体险，是团单
2. 整个承保，保权，理赔



## 得物面经

java jvm内存基础、

垃圾回收full gc和young gc区别

spring IOC



beanFactory和applicationcontext

​    回答：bf和ac都是spring容器，用于获得spring的bean，ac是bf的子接口,具有更多功能。

   1.beanFacroty的bean是懒加载，applicationcontext是立即加载

​    2.applicationcontext支持国际化MessageSource

​    3.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。



bean生命周期

动态代理



反射

  回答：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制



Redis数据结构

  回答：string set list zset hash   geography bitmap

数据库索引



spring让我介绍一下spring、springmvc、springboot、spring cloud 区别，通俗一点

https://www.zhihu.com/question/332686495/answer/1615131553

https://www.html.cn/qa/other/21703.html springcloud五大组件

eureka服务治理  ribbon 负载均衡 hytrix断路器 zuul网关 config配置管理



springboot自动配置原理

https://zhuanlan.zhihu.com/p/55637237?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

![image-20211121205135264](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211121205135264.png)

   回答：`@SpringBootApplication`等同于下面三个注解：

- `@SpringBootConfiguration`
- `@EnableAutoConfiguration`
- `@ComponentScan`

其中`@EnableAutoConfiguration`是关键(启用自动配置)，内部实际上就去加载`META-INF/spring.factories`文件的信息，然后筛选出以`EnableAutoConfiguration`为key的数据，加载到IOC容器中，实现自动配置功能！

每一个xxxAutoConfiguration类都是容器中的一个组件，并都加入到容器中。

加入到容器中之后的作用就是用它们来做自动配置，这就是Springboot自动配置之源，也就是自动配置的开始，只有这些自动配置类进入到容器中以后，接下来这个自动配置类才开始进行启动



sync和rlock的区别

hashmap扩容策略

分布式一致性设计



Q：redis渐进式rehash

*答案：redis的字典结构在扩容的时候，rehash不是一次完成的，因为在数据量过大的情况下，一次性执行rehash会对性能产生影响。因此，渐进式rehash指的是每次在字典进行增删改查操作的时候，对哈希表的一个数组单元的所有链表上的数据rehash。*

*在redis中，扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。*

*以下是哈希表渐进式 rehash 的详细步骤：*

*（1）为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。*

*（2）在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。*

*（3）在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。*

*（4）随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。*



aop原理，两种代理区别

jdk接口代理和  cglib字节码修改代理，子类



http长链接和短链接区别是什么

答案：1.0短连接，1.1支持长连接  指的是http请求结束后会保持一段时间的tcp连接，等后面客户端和服务器交互数据的时候可以复用这个tcp连接，减少多次建立连接的资源消耗。

mysql为什么用b+树

答案：b+树相对b树的好处

1.数据只在聚集索引的叶子节点当中，查询效率具有稳定性

2.由于非叶子节点没有全量数据，导致非叶子节点的同一磁盘页中可以容纳更多条数据，b+树具有矮胖的特征，一般三到四层就能存下大量数据。这样可以减少io次数

3.数据都在叶子节点中，具有链表连接的特性，适合范围查询。



幻读聊一下

mvcc和间隙锁



ES优化

kafka架构

redis 知乎上的



## 美团到店面经

1. 算法题：删除链表中的重复节点

2. hashmap中的get和put实现

3. hashmap的扩容

4. 高并发的时候hashmap会出现什么问题

5. HashMap若桶中链表元素超过8时，会自动转化成红黑树，为什么是8

6. 红黑树的原理

7. haspmap设置初始值，使其不用自动扩容（比如100个元素）

8. ThreadLocal原理

   答：ThreadLocal是线程私有的容器，见链接, 总结为，ThreadLocal包含一个静态内部类ThreadLocalMap, 在每个Thread对象中

   https://www.cnblogs.com/fsmly/p/11020641.html

   维护着ThreadLocalMap对象，其中以Entry<ThreadLocal, T value> 存储着值。

   entry里的threadlocal为什么用弱引用？

   https://zhuanlan.zhihu.com/p/158684233

   https://zhuanlan.zhihu.com/p/139214244

9. synchronize锁升级的原理



## soul面经(没啥参考价值)

1. SVM原理

2. PCA原理

3. redis分布式锁实现注意点

   https://www.zhihu.com/question/300767410/answer/1749442787

   回答：Redis实现分布式锁主要利用Redis的`setnx`命令。`setnx`是`SET if not exists`(如果不存在，则 SET)的简写。

   为了保证分布式锁的可用性，至少要确保锁的实现要同时满足以下几点：

   - 互斥性。在任何时刻，保证只有一个客户端持有锁。

   - 不能出现死锁。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。

   - 保证上锁和解锁都是同一个客户端。

     key是所有线程都一样的，value是不同的请求不一样

     实现流程：1.setnx试图获取锁

     ​                   2.获取锁后执行业务

     ​                   3.执行完业务后释放锁，释放锁前验证value是不是自己设置的

   注意点：1.为防止某线程持有锁期间挂掉，key需要设置过期时间，不然就死锁了

   ​                       过期时间一定要大于业务时间，不然还没执行完就释放了

   ​               2. 如何实现可重入锁？ 在setnx的基础上，用一个hash结构记录这个锁的重入次数。

   ​                  每次释放锁，重入次数-1，知道最后一次，真正释放锁的key。

   ​                  为了保证操作的原子性，用lua脚本执行枷锁和解锁

   ​				3. 粗糙的设计是，获取锁失败之后轮询，但是这样太耗费资源了。

   ​					用发布订阅模式优化：

   ​					当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。

   ​					当持有锁的客户端释放锁的时候，发布锁释放的消息。

   ​					当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。

   ##### redis缓存击穿问题解决

   

4. 不记得了



## 阿里一面

1. redis分布式锁

2. 多数据源幂等

3. es深度分页问题

4. redis常见问题

   ![image-20211105231922844](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211105231922844.png)

   ### 分布式系统和事务

   https://www.zhihu.com/question/54105974 CAP理论中的P到底是个什么意思？

   https://mp.weixin.qq.com/s/sqLw4QEmZ5H2uYpQQUKZwA聊聊分布式事务方案Seata的那些过人之处

      1.什么是 CAP 理论？

      2.CAP 中的 P 是什么意思？

      3.为什么说分布式系统，只能在 C、A 中二选一？ 

   **当没有出现分区问题的时候，系统就应该有完美的数据一致性和可用性。**

   因为当出现分区节点故障的时候，节点数据不同步，这时候需要做出选择，满足可用性就会出现数据不一致，满足一致性就需要推迟暂停当前的数据访问。

      4.结合实际应用，CP、AP 该怎么选择？

   分布式系统包含许多子系统，根据子系统的特性对一致性和可用性分别做选择

   比如当我们做一套支付系统的时候，会员的财务相关像账户余额，账务流水是必须强一致性的。这时候，你就要考虑选 C。但是，会员的名字，会员的支付设置就不必考虑强一致性，可以选择可用性 A。

   #### 注册中心 eureka nacos
   
   #### 事务消息
   
   https://zhuanlan.zhihu.com/p/365001001?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn
   
   事务消息应用场景、实现原理与项目实战(附全部源码)
   
   #### Spring声明式事务什么时候不生效
   
   事务的传播机制
   
   

