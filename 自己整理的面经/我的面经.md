

### Java基础

##### 1.注解怎么自己创建，有哪些元注解，一般怎么利用？

https://www.zhihu.com/question/24401191

1. public @interface MyAnnotation {  //创建自定义注解

   ​	String value() default "hahaha"; }  //属性值

   等同于

   public class MyAnnotation extends java.lang.annotation.Annotation{   
        private String value = "hahaha";   
        public void setValue(String value){   
             this.value = value;   
        }   
        public String getValue(){   
             return value;   
         }   

   }

   ————————————————

2. 元注解

   1. @Target 作用域 方法，field， class, 方法参数, 局部变量
   2. @Retention 生命周期，Source源代码, Class编译, Runtime运行
   3. @Documented 会记录进doc
   4. @Inherited 子类会继承注解

3. 怎么利用注解
   1. 可以用反射获取注解，然后针对拥有特定注解的方法/类做不同的操作。
   2. 可以在aop当中把注解当作切入点，对拥有此注解的方法用aop执行特定操作。

##### 2.线程池有哪些参数？分别有什么用？线程添加进线程池后会发生什么？

  核心线程数，最大线程数， 阻塞队列， keepAliveTime， 抛弃策略

​	线程放入线程池，1.核心线程没用完, 用核心线程执行 2用完了，去阻塞队列排队 3队列满了，开最大现场数中的线程来执行 3.超过最大线程数, 执行抛弃策略

​	抛弃策略有哪些？：1.直接抛弃 2.抛弃任务并且报异常 3. 抛弃等待队列里排在最前面的任务 4.调用当前线程来执行这个任务。

https://www.jianshu.com/p/9f6e07452c10

​	阻塞队列有哪些？ 1.无界队列LinkedBlockingQueue链表组成的无界队列   2.有界队列ArrayBlockingQueue 3.同步移交队列SynchronousQueue 如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。4.DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务。**DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。**

**不同线程池采用的阻塞队列:**

1. FixedThreadPool: 核心线程数和最大线程数相同。采用LinkedThreadPool 无界队列，因为用不着最大线程数，只能排队等核心线程数。
2. SingleThreadPool: 线程数只有一个，采用LinkedThreadPool 无界队列，因为用不着最大线程数，只能排队等核心线程数。
3. CachedThreadPool: 核心线程数0，最大线程数Int.max。阻塞队列：SynchronousQueue。CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。
4. SheduledThreadPoll: 可以定时执行任务，用的DelayedWorkQueue .

##### 3.Unsafe类

对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。

Java 有个类叫 `Unsafe` 类，这个类类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。

线程挂起与恢复、CAS都是通过unsafe类实现的

##### 4.简述java创建对象的过程

##### 5.java不同的线程分配对象空间如何保证线程安全

1. 对分配内存空间采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。
2. 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配。一般采用这种策略。

##### 6.简述对象的内存布局

对象在堆内存的存储布局可分为**对象头**、**实例数据**和**对齐填充**。

对象头主要包含两部分数据： MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。 类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据，

实例数据存储代码中所定义的各种类型的字段信息。

对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。



##### 7.简述java的引用类型

强引用： 被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。

软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。

弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。

虚引用： 无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。

##### **8.简述JVM类加载过程**

加载：

1. 通过全类名获取类的二进制字节流.
2. 将类的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成类的Class对象，作为方法区数据的入口。

验证：对文件格式，元数据，字节码，符号引用等验证正确性。

准备：在方法区内为类变量分配内存并设置为0值。

解析：将符号引用转化为直接引用。

初始化：执行类构造器clinit方法，真正初始化。

##### 9.java内存泄漏有哪些原因？

1. 静态集合类的生命周期是整个程序
2. 没有释放各种连接(数据库，io)
3. Set里的对象如果hashcode的成员变量修改了可能就再也没法remove掉了
4. 单例模式的饿汉式，对象一直存在

### Spring

###### 1.spring循环依赖是怎么解决的？

https://zhuanlan.zhihu.com/p/157611040?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

三级缓存!  要考虑到aop代理的对象！



###### 2.Spring容器之refresh方法

https://zhuanlan.zhihu.com/p/354691875

![image-20211212113409664](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211212113409664.png)

###### 3@transaction注解原理，事务传播机制, @transactional失效的场景

 https://zhuanlan.zhihu.com/p/145897825?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

https://zhuanlan.zhihu.com/p/361377807?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

传播机制： required_new    required  support  not_support  never

失效情况  1 not public  2 不正确的传播机制  3 不正确的rollbackFor

​                 4.@transactional方法被同类的非事务方法调用，就会调用原生而非aop代理的事务方法  5. @transactional修饰的方法异常被try catch处理 了，导致aop的代理方法无法走到try catch之后rollback

6.数据库本身的存储引擎不支持事务，比如myisam



### JVM

java并发面试题总结：

https://www.zhihu.com/question/511409941/answer/2309942619?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_content=group2_Answer&utm_campaign=shareopn

##### 1.volatile的作用，为什么能防止指令重排序？内存屏障的作用？happends-before规则？

https://blog.csdn.net/u012988901/article/details/111313057

https://blog.csdn.net/TZ845195485/article/details/117601980

##### 2.as-if-serial和happends-before规则d的区别

as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。



##### 3.java内存模型

1. Java内存模型的抽象结构

   线程之间的「共享变量」存储在「主内存」中，每个线程都有自己私有的「本地内存」，「本地内存」存 储了该线程以读/写共享变量的副本。

2. happen-before规则

   程序次序规则， 加锁解锁规则， volatile写后读

   https://www.jianshu.com/p/9464bf340234 

   禁止CPU和编译器的重排序（保证了有序性）、保证CPU写核心的指令可以立即生效且其他核心的缓存数据失效（保证了可见性

   3.对volatile内存语义的探讨



### 同步

#### 1.reentrantlock实现原理，aqs

 资料：《 java并发编程的艺术》P121

​             https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html  美团技术团队aqs

​			https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect 美团技术团队 不可不说的java锁事

https://developer.51cto.com/art/202011/631201.htm ReentrantLock核心原理

  **AQS基本组件及作用：**

1.双向链表等待队列 2volatile int state 3 ownerThread

  **公平锁和非公平锁实现原理**

https://www.bilibili.com/read/cv5333437/  **面试官：说一下公平锁和非公平锁的区别**

​      公平锁：1尝试获取锁的时候，发现队列有等待的线程，就只能乖乖去排队2当头节点释放锁的时候，只有没有前驱节点的节点才能获取锁（头节点）

 	 非公平锁：1多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。2当头节点释放锁的时候，所有节点都有机会用cas获取锁

  差别：非公平锁效率高，吞吐量大，公平锁能减少饥饿大声的概率，不会让一个线程

  **可中断锁实现原理**

  **可重入锁实现原理：**

​     Aqs有个volatile的int变量state，0表示无锁状态，1-n表示锁占有状态以及重入次数，在多次重入时state+1，每次释放锁state-1，直到state=0，释放锁。

​	**锁超时等待原理：**

  **读写锁ReadWriteLock**：

https://zhuanlan.zhihu.com/p/91408261?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

volatile分成两部分，一部分记录读锁的状态，一部分记录写锁的状态

**独占锁和共享锁的实现原理：**

共享锁的流程和独占锁类似，有以下区别
1、锁工具对应的tryAcquire()实现方法不一样，tryAcquire()的返回值如果大于等于0代表抢锁成功，大于0代表还有剩余资源供其他线程抢夺。
2、共享锁除了在释放锁的时候唤醒线程，在抢占成功后，如果返回值大于0，也会从尾到头唤醒线程来抢夺锁，加快了唤醒线程的速度。

### 多线程

##### **1.线程生命周期图**

https://zhuanlan.zhihu.com/p/162945062



##### **2.ThreadLocal**

答：ThreadLocal是线程私有的容器，见链接, 总结为，ThreadLocal包含一个静态内部类ThreadLocalMap, 在每个Thread对象中

https://www.cnblogs.com/fsmly/p/11020641.html

维护着ThreadLocalMap对象，其中以Entry<ThreadLocal, T value> 存储着值。

entry里的threadlocal为什么用弱引用？

https://zhuanlan.zhihu.com/p/158684233

https://zhuanlan.zhihu.com/p/139214244



##### 3.CountDownLatch

https://www.jianshu.com/p/dcb32bffcdb3

作用：有两个方法，一个await()等待阻塞直到数字变为0, 一个countDown()使得数字-1;

一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行

主服务await()，其他线程在执行完毕后都countDown()，这样其他线程结束后主服务就继续了。



##### 4.CyclicBarrier

一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。

使用方法：线程里的CyclicBarrier.await(), 等所有线程都到达await()这个屏障就一起释放

https://baijiahao.baidu.com/s?id=1648194641516761359&wfr=spider&for=pc



两者的区别：CountDownLatch分为等待的线程await()和计数的线程countDown()，当计数的线程计数完毕后等待的线程释放。

而CyclicBarrier则都要await(),到达阻塞点后一起释放。

### Mysql

##### 1.ACID事务的四大属性是如何实现的？

  原子性：事务，undolog提供回滚能力

  持久性：redolog保证持久化

  隔离性：mvcc和锁机制保证了不同的隔离级别

  一致性：前三个特性保证了一致性，也就是保持在事务前和事务后的两种合理状态

##### 2.介绍一下Mysql三大日志？Undolog  redolog binlog

https://zhuanlan.zhihu.com/p/93131864?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn   redolog的介绍

https://www.bianchengquan.com/article/357198.html  binlog的介绍



##### Redolog:

- Mysql由于cpu速度与磁盘速度的鸿沟，引入缓存池的概念，数据的写都是先在内存中操作，然后异步刷新到此磁盘
- Mysql buffer刷新到磁盘的过程是一个随机写的过程
- Mysql通过redo log 顺序写的优势来保证内存与磁盘的数据一致性
- Redo log的刷盘策略决定了mysql事务的强一致性，还是弱一致性
- 事务的设置强一致性还是弱一致性要看具体使用场景
- ***redolog是物理日志，记录的是每个数据页的数据变化，在数据持久化之后就废弃了，可以被覆盖，因此占用的空间不大

**binlog:**

- binlog的主要作用是提供主从复制的日志数据
- 形式是逻辑日志，有statement(sql语句) row(每行数据的变化) statement(两种组合)

**undolog:**

- 重做日志，记录不同事务下对同一行数据的多版本变化，用于提供事务回滚的能力

**为啥不能用redolog来主从复制：**

①因为redolog不是全量日志！是可覆盖的，数据持久化后redolog就没用了！

②是物理日志，数据页的变化，换到slavery节点没用

**为啥不能用binlog来崩溃恢复？**

①binlog是全量日志，崩溃之后不知道从哪里开始恢复

**数据提交时如何保证redolog和undolog的一致性(master和slave的一致性)？** 

https://www.zhihu.com/question/463438061/answer/2280710259?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_content=group1_Answer&utm_campaign=shareopn 

redolog的两阶段提交: redolog(prepare) --> undolog --> redolog(commit)



##### 3.mysql有哪些索引结构？

B+树, hash索引， 全文索引(倒排索引)



##### 4.hash索引那么快，为什么不全用hash索引？

①hash索引只适合单个的查询，不能提供告诉的范围查询和排序

②hash索引在大量hash碰撞后效率不一定高



##### 5.索引失效的情况？

1.like 2.组合索引 3.索引上加上计算、函数、类型转换 4.索引用not in/ != / <>



##### 6.聚集索引和非聚集索引的区别

https://www.bianchengquan.com/article/357198.html

①叶子节点是否存储数据 

②是否回表

③**聚集索引：**行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的，所以**查询效率快**，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是**修改慢**，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序

④非聚集索引：**非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。**修改数据不会造成行数据重排。



##### 7.mysql如何预防和解决死锁

1）不同的应用访问同一组表时，应尽量约定以相同的顺序访问各表。对一个表而言，应尽量以固定的顺序存取表中的行。这点真的很重要,它可以明显的减少死锁的发生。

举例：好比有a,b两张表，如果事务1先a后b,事务2先b后a,那就可能存在相互等待产生死锁。那如果事务1和事务2都先a后b，那事务1先拿到a的锁，事务2再去拿a的锁，如果锁冲突那就会等待事务1释放锁，那自然事务2就不会拿到b的锁，那就不会堵塞事务1拿到b的锁，这样就避免死锁了。

2）在主键等值更新的时候，尽量先查询看数据库中有没有满足条件的数据，如果不存在就不用更新，存在才更新。为什么要这么做呢，因为如果去更新一条数据库不存在的数据，一样会产生间隙锁。

举例：如果表中只有id=1和id=5的数据，那么如果你更新id=3的sql，因为这条记录表中不存在，那就会产生一个(1,5)的间隙锁，但其实这个锁就是多余的，因为你去更新一个数据都不存在的数据没有任何意义。

3）尽量使用主键更新数据,因为主键是唯一索引，在等值查询能查到数据的情况下只会产生行锁，不会产生间隙锁，这样产生死锁的概率就减少了。当然如果是范围查询，一样会产生间隙锁。

4）避免长事务，小事务发送锁冲突的几率也小。这点应该很好理解。

5）在允许幻读和不可重复度的情况下，尽量使用RC的隔离级别，避免gap lock造成的死锁，因为产生死锁经常都跟间隙锁有关，间隙锁的存在本身也是在RR隔离级别来解决幻读的一种措施。

如果发生了死锁，看mysql的死锁的日志

### Redis

**1.常见的缓存策略有哪些？**

https://www.cnblogs.com/javaguide/p/14154495.html

查询：差缓存，没有就查数据库并写缓存

更新：1.先更新数据库然后让缓存失效  2.更新缓存后同步更新数据库  3. 更新缓存后异步更新数据库



**2.常见的缓存策略及击穿穿透，雪崩的解决方案**

https://blog.csdn.net/qq_33101689/article/details/105245986

redis击穿：缓存未命中，短期内频繁到达数据库查询：

​	解决方案：1事前采用布隆过滤器排除无效的key 2 用分布式锁或者本地锁控制只有一个节点去访问数据库并且回写到redis

redis穿透：缓存和数据库都没有命中

​	解决方案：1事前采用布隆过滤器排除无效的key   2 对于无效的key，redis写空值

redis雪崩：

​	解决方案：事前：1.用哨兵模式，集群提高健壮性2.rediskey的失效时间尽可能设置带随机性，减少同时失效的可能性。    事中，如果redis挂了就服务降级或者服务熔断，没挂就用锁访问数据库回写redis 
事后，用日志快速恢复数据 ，快速预热重启redis

**3.redis为什么那么快？**

单线程+io多路复用+内存+独特的数据结构优化机制

**4.redis有哪些集群？**

https://zhuanlan.zhihu.com/p/382817870?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

https://zhuanlan.zhihu.com/p/129640817?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

1. 主从复制

   可以读写分离，但是可用性不高，主服务器挂了就挂了

2. 哨兵模式

   用哨兵集群监控主节点和从节点的状态，在主节点挂了的时候投票选举从节点成为新的主节点，提高系统的可用性。

3. Cluster集群模式

   哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题**。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容**，来解决在线扩容的问题。如图

   ![preview](https://pic3.zhimg.com/v2-0a5c207d9800ccc516f89650f7f957a6_r.jpg)

   Cluster模式的具体工作机制：

   

   - 在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383
   - 当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作
   - 为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
   - 当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了

**5.aof和rdb持久化方式**

​	**RDB:** 

​	快照日志   

​	持久化时机设置：每XX时间内至少修改XX次 触发

​	创建和载入RDB文件，可能存在的服务器状态有以下3种：

1. 当执行SAVE命令时，Redis服务器会被阻塞，此时客户端发送的所有命令请求都会被阻塞，只有在服务器执行完SAVE命令，重新开始接受命令请求之后，客户端发送的命令请求才会被处理。
2. 当执行BGSAVE命令时，Redis服务器不会被阻塞，Redis服务器仍然可以继续处理客户端发送的命令请求。
3. 服务器在载入RDB文件期间，会一直处于阻塞状态，直到RDB文件载入成功。

​    **AOF:**  

​     记录redis写命令

​	 持久化时机：

1. always
   从安全性来说，always是最安全的（丢失数据最少），因为即使出现故障停机，数据库也只会丢失一个事件循环中所产生的命令数据。
   从效率来说，always的效率最慢，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且同步AOF文件。

2. everysec
   从安全性来说，everysec模式下，即使出现故障停机，数据库只会丢失一秒钟的命令数据。
   从效率来说，everysec模式足够快，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行同步。

3. no
   从安全性来说，no模式下，如果出现故障停机，数据库会丢失上次同步AOF文件之后的所有写命令数据，具有不确定性，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。
   从效率来说，no模式和everysec模式的效率差不多。

   **AOF重写**

   因为AOF持久化是通过保存被执行的写命令来记录数据库数据的，所以随着Redis服务器运行时间的增加，AOF文件中的内容会越来越多，文件的体积会越来越大。Redis提供了AOF文件重写功能，即Redis服务器会创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库数据相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小很多。

**AOF和RDB对比：**

1. 实现方式   快照 vs 命令
2. 文件体积   aof>rdb
3. 安全性       aof>rdb
4. 优先级       aof>rdb

### 分布式

#### 1.分布式环境下生成唯一id

雪花算法：64位long包含 时间戳+机器编号+序列号

可以保证每秒钟，每台机器能产生 序列号长度那么多的不同id



#### 2.Redis分布式锁，redlock

https://zhuanlan.zhihu.com/p/374732293?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

https://zhuanlan.zhihu.com/p/418268774?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

redis分布式锁实现注意事项：

回答：Redis实现分布式锁主要利用Redis的`setnx`命令。`setnx`是`SET if not exists`(如果不存在，则 SET)的简写。

为了保证分布式锁的可用性，至少要确保锁的实现要同时满足以下几点：

- 互斥性。在任何时刻，保证只有一个客户端持有锁。

- 不能出现死锁。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。

- 保证上锁和解锁都是同一个客户端。

  key是所有线程都一样的，value是不同的请求不一样

  实现流程：1.setnx试图获取锁

  ​                   2.获取锁后执行业务

  ​                   3.执行完业务后释放锁，释放锁前验证value是不是自己设置的

注意点：1.为防止某线程持有锁期间挂掉，key需要设置过期时间，不然就死锁了

​                       过期时间一定要大于业务时间，不然还没执行完就释放了, 

​						或者定期续约，增加expire的时间

​               2. 如何实现可重入锁？ 在setnx的基础上，用一个hash结构记录这个锁的重入次数。

​                  每次释放锁，重入次数-1，知道最后一次，真正释放锁的key。

​                  为了保证操作的原子性，用lua脚本执行枷锁和解锁

​				3. 粗糙的设计是，获取锁失败之后轮询，但是这样太耗费资源了。

​					用发布订阅模式优化：

​					当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。

​					当持有锁的客户端释放锁的时候，发布锁释放的消息。

​					当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。

redlock原理：

#### 3. 一致性hash算法

https://blog.csdn.net/qq_33945246/article/details/105113417

是什么：使请求hash分配到多个节点，并且在节点增加或者减少时，能使大多数原本的请求命中相同的节点

怎么做：hash环+虚拟节点+请求hash映射到环上后顺时针查找

#### 4. 分布式事务：

1.分布式事务的原理,优缺点,如何使用分布式事务,2pc 3pc 的区别,解决了哪些问题,还有哪些问题没解决,如何解决,你自己项目里涉及到分布式事务是怎么处理的.



### 设计模式

#### 1.你在工作中用过哪些设计模式？

单例模式

工厂模式

模板方法模式

装饰模式

代理模式

门面模式



### 计算机网络

#####   1. 什么是TCP粘包

​	TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。

#####  2.TCP粘包的处理方法

   1.固定发送信息长度，读取的时候也固定

2.或在两个信息之间加入分隔符，每个信息用固定的开始和结尾的分隔符。

#####  3.TCP三次握手过程

1. 第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq=x，并将该数据包发送给服务端，客户端 进入**syn_sent****状态，等待服务端确认。
2. 第二次握手:服务端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack=x+1,随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入**syn_rcvd**状态。
3. 第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了

#####  4.为什么TCP握手需要三次，两次行不行？

不行。TCP进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。

如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。

##### **5.简述半连接队列**

TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。

##### 6.TCP四次挥手过程

![image-20220130120313381](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20220130120313381.png)

1. 第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin*wait*1状态。

2. 第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。

3. 第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。

4. 第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。

   

##### 7.Timewait  为什么等待两个msl时间

第一，为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。
第二，A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段

##### 8.HTTPS原理

https://zhuanlan.zhihu.com/p/36981565

- 通过CA体系交换public key
- 通过非对称加密算法，交换用于对称加密的密钥
- 通过对称加密算法，加密正常的网络通信

这基本就是SSL/TLS的工作过程了

https的连接过程

1. 浏览器将支持的加密算法信息发给服务器
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
3. 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
4. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器
5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
6. 服务器将加密后的密文发送给客户端
7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成

##### 9.简述dos攻击

DoS是Denial of Service的简称，也称为拒绝服务攻击，通过发送大量的无用请求数据包给服务器，耗尽服务器资源，从而无法通过正常的访问服务器资源，导致服务器崩溃。

### 其他

1. rpc的流程，原理，需要解决什么问题

   https://zhuanlan.zhihu.com/p/391186905

2. 开发中的设计原则，比如开闭原则

3. mybatis底层原理

   https://www.zhihu.com/question/25007334/answer/2029576882?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_content=group1_Answer&utm_campaign=shareopn

4. ###### 接口幂等性如何实现

   https://zhuanlan.zhihu.com/p/127169053?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

   https://zhuanlan.zhihu.com/p/101274125?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

   思路：为需要保证幂等性的每一次请求创建一个唯一标识token, 先获取token, 并将此token存入redis, 请求接口时, 将此token放到header或者作为请求参数请求接口, 后端接口判断redis中是否存在此token:

   - 如果存在, 正常处理业务逻辑, 并从redis中删除此token, 那么, 如果是重复请求, 由于token已被删除, 则不能通过校验, 返回请勿重复操作提示
   - 如果不存在, 说明参数不合法或者是重复请求, 返回提示即可

5. 如何设计一个秒杀系统

6. 设计一个短域名服务需要考虑哪些点？

   https://zhuanlan.zhihu.com/p/428419610

   1.如何生成唯一的全局id作为短域名的一部分？

   ① mysql自增主键，②redis的value incry by ③雪花算法

   2.太长了怎么办？

   压缩域名，用0-9 A-Z a-z 62进制

   3.访问短连接如何转到对于的长链接？

   通过数据库和redis存储的数据，用短链接查出长链接，然后重定向到长链接！

​       4.怎么抗住高并发？

​		①合理使用redis缓存取长链接数据 ②用布隆过滤器过滤请求，无效的短链接无法进入后面
