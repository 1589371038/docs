

### Java基础

##### 1.注解怎么自己创建，有哪些元注解，一般怎么利用？

https://www.zhihu.com/question/24401191

1. public @interface MyAnnotation {  //创建自定义注解

   ​	String value() default "hahaha"; }  //属性值

   等同于

   public class MyAnnotation extends java.lang.annotation.Annotation{   
        private String value = "hahaha";   
        public void setValue(String value){   
             this.value = value;   
        }   
        public String getValue(){   
             return value;   
         }   

   }

   ————————————————

2. 元注解

   1. @Target 作用域 方法，field， class, 方法参数, 局部变量
   2. @Retention 生命周期，Source源代码, Class编译, Runtime运行
   3. @Documented 会记录进doc
   4. @Inherited 子类会继承注解

3. 怎么利用注解
   1. 可以用反射获取注解，然后针对拥有特定注解的方法/类做不同的操作。
   2. 可以在aop当中把注解当作切入点，对拥有此注解的方法用aop执行特定操作。

##### 2.线程池有哪些参数？分别有什么用？线程添加进线程池后会发生什么？

  核心线程数，最大线程数， 阻塞队列， keepAliveTime， 抛弃策略

​	线程放入线程池，1.核心线程没用完, 用核心线程执行 2用完了，去阻塞队列排队 3队列满了，开最大现场数中的线程来执行 3.超过最大线程数, 执行抛弃策略

​	抛弃策略有哪些？：1.直接抛弃 2.抛弃任务并且报异常 3. 抛弃等待队列里排在最前面的任务 4.调用当前线程来执行这个任务。

https://www.jianshu.com/p/9f6e07452c10

​	阻塞队列有哪些？ 1.无界队列LinkedBlockingQueue链表组成的无界队列   2.有界队列ArrayBlockingQueue 3.同步移交队列SynchronousQueue 如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。4.DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务。**DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。**

**不同线程池采用的阻塞队列:**

1. FixedThreadPool: 核心线程数和最大线程数相同。采用LinkedThreadPool 无界队列，因为用不着最大线程数，只能排队等核心线程数。
2. SingleThreadPool: 线程数只有一个，采用LinkedThreadPool 无界队列，因为用不着最大线程数，只能排队等核心线程数。
3. CachedThreadPool: 核心线程数0，最大线程数Int.max。阻塞队列：SynchronousQueue。CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。
4. SheduledThreadPoll: 可以定时执行任务，用的DelayedWorkQueue .

##### 3.Unsafe类

对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。

Java 有个类叫 `Unsafe` 类，这个类类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。

线程挂起与恢复、CAS都是通过unsafe类实现的

##### 4.简述java创建对象的过程

##### 5.java不同的线程分配对象空间如何保证线程安全

1. 对分配内存空间采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。
2. 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配。一般采用这种策略。

##### 6.简述对象的内存布局

对象在堆内存的存储布局可分为**对象头**、**实例数据**和**对齐填充**。

对象头主要包含两部分数据： MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。 类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据，

实例数据存储代码中所定义的各种类型的字段信息。

对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。



##### 7.简述java的引用类型

强引用： 被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。

软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。

弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。

虚引用： 无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。

##### **8.简述JVM类加载过程**

加载：

1. 通过全类名获取类的二进制字节流.
2. 将类的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成类的Class对象，作为方法区数据的入口。

验证：对文件格式，元数据，字节码，符号引用等验证正确性。

准备：在方法区内为类变量分配内存并设置为0值。

解析：将符号引用转化为直接引用。

初始化：执行类构造器clinit方法，真正初始化。

##### 9.java内存泄漏有哪些原因？

1. 静态集合类的生命周期是整个程序
2. 没有释放各种连接(数据库，io)
3. Set里的对象如果hashcode的成员变量修改了可能就再也没法remove掉了
4. 单例模式的饿汉式，对象一直存在

### Spring

###### 1.spring循环依赖是怎么解决的？

https://zhuanlan.zhihu.com/p/157611040?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

三级缓存!  要考虑到aop代理的对象！



###### 2.Spring容器之refresh方法

https://zhuanlan.zhihu.com/p/354691875

![image-20211212113409664](C:\Users\丁传传\AppData\Roaming\Typora\typora-user-images\image-20211212113409664.png)

###### 3@transaction注解原理，事务传播机制, @transactional失效的场景

 https://zhuanlan.zhihu.com/p/145897825?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

https://zhuanlan.zhihu.com/p/361377807?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

传播机制： required_new    required  support  not_support  never

失效情况  1 not public  2 不正确的传播机制  3 不正确的rollbackFor

​                 4.@transactional方法被同类的非事务方法调用，就会调用原生而非aop代理的事务方法  5. @transactional修饰的方法异常被try catch处理 了，导致aop的代理方法无法走到try catch之后rollback

6.数据库本身的存储引擎不支持事务，比如myisam



### JVM

##### 1.volatile的作用，为什么能防止指令重排序？内存屏障的作用？happends-before规则？

https://blog.csdn.net/u012988901/article/details/111313057

https://blog.csdn.net/TZ845195485/article/details/117601980

##### 2.as-if-serial和happends-before规则d的区别

as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。



### 同步

#### 1.reentrantlock实现原理，aqs

 资料：《 java并发编程的艺术》P121

​             https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html  美团技术团队aqs

​			https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect 美团技术团队 不可不说的java锁事

https://developer.51cto.com/art/202011/631201.htm ReentrantLock核心原理

  **AQS基本组件及作用：**

1.双向链表等待队列 2volatile int state 3 ownerThread

  **公平锁和非公平锁实现原理**

https://www.bilibili.com/read/cv5333437/  **面试官：说一下公平锁和非公平锁的区别**

​      公平锁：1尝试获取锁的时候，发现队列有等待的线程，就只能乖乖去排队2当头节点释放锁的时候，只有没有前驱节点的节点才能获取锁（头节点）

 	 非公平锁：1多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。2当头节点释放锁的时候，所有节点都有机会用cas获取锁

  差别：非公平锁效率高，吞吐量大，公平锁能减少饥饿大声的概率，不会让一个线程

  **可中断锁实现原理**

  **可重入锁实现原理：**

​     Aqs有个volatile的int变量state，0表示无锁状态，1-n表示锁占有状态以及重入次数，在多次重入时state+1，每次释放锁state-1，直到state=0，释放锁。

​	**锁超时等待原理：**

  **读写锁ReadWriteLock**：

https://zhuanlan.zhihu.com/p/91408261?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

volatile分成两部分，一部分记录读锁的状态，一部分记录写锁的状态

**独占锁和共享锁的实现原理：**

共享锁的流程和独占锁类似，有以下区别
1、锁工具对应的tryAcquire()实现方法不一样，tryAcquire()的返回值如果大于等于0代表抢锁成功，大于0代表还有剩余资源供其他线程抢夺。
2、共享锁除了在释放锁的时候唤醒线程，在抢占成功后，如果返回值大于0，也会从尾到头唤醒线程来抢夺锁，加快了唤醒线程的速度。

### 多线程

##### **1.线程生命周期图**

https://zhuanlan.zhihu.com/p/162945062



##### **2.ThreadLocal**

答：ThreadLocal是线程私有的容器，见链接, 总结为，ThreadLocal包含一个静态内部类ThreadLocalMap, 在每个Thread对象中

https://www.cnblogs.com/fsmly/p/11020641.html

维护着ThreadLocalMap对象，其中以Entry<ThreadLocal, T value> 存储着值。

entry里的threadlocal为什么用弱引用？

https://zhuanlan.zhihu.com/p/158684233

https://zhuanlan.zhihu.com/p/139214244



##### 3.CountDownLatch

https://www.jianshu.com/p/dcb32bffcdb3

作用：有两个方法，一个await()等待阻塞直到数字变为0, 一个countDown()使得数字-1;

一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行

主服务await()，其他线程在执行完毕后都countDown()，这样其他线程结束后主服务就继续了。



##### 4.CyclicBarrier

一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。

使用方法：线程里的CyclicBarrier.await(), 等所有线程都到达await()这个屏障就一起释放

https://baijiahao.baidu.com/s?id=1648194641516761359&wfr=spider&for=pc



两者的区别：CountDownLatch分为等待的线程await()和计数的线程countDown()，当计数的线程计数完毕后等待的线程释放。

而CyclicBarrier则都要await(),到达阻塞点后一起释放。

### Mysql

1.ACID事务的四大属性是如何实现的？

  原子性：事务，undolog提供回滚能力

  持久性：redolog保证持久化

  隔离性：mvcc和锁机制保证了不同的隔离级别

  一致性：前三个特性保证了一致性，也就是保持在事务前和事务后的两种合理状态

2.介绍一下Mysql三大日志？Undolog  redolog binlog

https://zhuanlan.zhihu.com/p/93131864?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn   redolog的介绍

https://www.bianchengquan.com/article/357198.html  binlog的介绍



##### Redolog:

- Mysql由于cpu速度与磁盘速度的鸿沟，引入缓存池的概念，数据的写都是先在内存中操作，然后异步刷新到此磁盘
- Mysql buffer刷新到磁盘的过程是一个随机写的过程
- Mysql通过redo log 顺序写的优势来保证内存与磁盘的数据一致性
- Redo log的刷盘策略决定了mysql事务的强一致性，还是弱一致性
- 事务的设置强一致性还是弱一致性要看具体使用场景
- ***redolog是物理日志，记录的是每个数据页的数据变化，在数据持久化之后就废弃了，可以被覆盖，因此占用的空间不大

**binlog:**

- binlog的主要作用是提供主从复制的日志数据
- 形式是逻辑日志，有statement(sql语句) row(每行数据的变化) statement(两种组合)

**undolog:**

- 重做日志，记录不同事务下对同一行数据的多版本变化，用于提供事务回滚的能力

**为啥不能用redolog来主从复制：**

①因为redolog不是全量日志！是可覆盖的，数据持久化后redolog就没用了！

②是物理日志，数据页的变化，换到slavery节点没用

**为啥不能用binlog来崩溃恢复？**

①binlog是全量日志，崩溃之后不知道从哪里开始恢复

**数据提交时如何保证redolog和undolog的一致性(master和slave的一致性)？** 

https://www.zhihu.com/question/463438061/answer/2280710259?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_content=group1_Answer&utm_campaign=shareopn 

redolog的两阶段提交: redolog(prepare) --> undolog --> redolog(commit)



3.mysql有哪些索引结构？

B+树, hash索引， 全文索引(倒排索引)



4.hash索引那么快，为什么不全用hash索引？

①hash索引只适合单个的查询，不能提供告诉的范围查询和排序

②hash索引在大量hash碰撞后效率不一定高



5.索引失效的情况？

1.like 2.组合索引 3.索引上加上计算、函数、类型转换 4.索引用not in/ != / <>



6.聚集索引和非聚集索引的区别

https://www.bianchengquan.com/article/357198.html

①叶子节点是否存储数据 

②是否回表

③**聚集索引：**行数据在物理储器中的真实地址就是按照主键索引树形成的顺序进行排列的，所以**查询效率快**，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是**修改慢**，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序

④非聚集索引：**非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。**修改数据不会造成行数据重排。



### Redis

**1.常见的缓存策略有哪些？**

https://www.cnblogs.com/javaguide/p/14154495.html

查询：差缓存，没有就查数据库并写缓存

更新：1.先更新数据库然后让缓存失效  2.更新缓存后同步更新数据库  3. 更新缓存后异步更新数据库



**2.常见的缓存策略及击穿穿透，雪崩的解决方案**

https://blog.csdn.net/qq_33101689/article/details/105245986

redis击穿：缓存未命中，短期内频繁到达数据库查询：

​	解决方案：1事前采用布隆过滤器排除无效的key 2 用分布式锁或者本地锁控制只有一个节点去访问数据库并且回写到redis

redis穿透：缓存和数据库都没有命中

​	解决方案：1事前采用布隆过滤器排除无效的key   2 对于无效的key，redis写空值

redis雪崩：

​	解决方案：事前：1.用哨兵模式，集群提高健壮性2.rediskey的失效时间尽可能设置带随机性，减少同时失效的可能性。    事中，如果redis挂了就服务降级或者服务熔断，没挂就用锁访问数据库回写redis 
事后，用日志快速恢复数据 ，快速预热重启redis

**3.redis为什么那么快？**

单线程+io多路复用+内存+独特的数据结构优化机制

**4.redis有哪些集群？**

https://zhuanlan.zhihu.com/p/382817870?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

https://zhuanlan.zhihu.com/p/129640817?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

1. 主从复制

   可以读写分离，但是可用性不高，主服务器挂了就挂了

2. 哨兵模式

   用哨兵集群监控主节点和从节点的状态，在主节点挂了的时候投票选举从节点成为新的主节点，提高系统的可用性。

3. Cluster集群模式

   哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题**。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容**，来解决在线扩容的问题。如图

   ![preview](https://pic3.zhimg.com/v2-0a5c207d9800ccc516f89650f7f957a6_r.jpg)

   Cluster模式的具体工作机制：

   

   - 在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383
   - 当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作
   - 为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
   - 当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了

**5.aof和rdb持久化方式**

​	**RDB:** 

​	快照日志   

​	持久化时机设置：每XX时间内至少修改XX次 触发

​	创建和载入RDB文件，可能存在的服务器状态有以下3种：

1. 当执行SAVE命令时，Redis服务器会被阻塞，此时客户端发送的所有命令请求都会被阻塞，只有在服务器执行完SAVE命令，重新开始接受命令请求之后，客户端发送的命令请求才会被处理。
2. 当执行BGSAVE命令时，Redis服务器不会被阻塞，Redis服务器仍然可以继续处理客户端发送的命令请求。
3. 服务器在载入RDB文件期间，会一直处于阻塞状态，直到RDB文件载入成功。

​    **AOF:**  

​     记录redis写命令

​	 持久化时机：

1. always
   从安全性来说，always是最安全的（丢失数据最少），因为即使出现故障停机，数据库也只会丢失一个事件循环中所产生的命令数据。
   从效率来说，always的效率最慢，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且同步AOF文件。

2. everysec
   从安全性来说，everysec模式下，即使出现故障停机，数据库只会丢失一秒钟的命令数据。
   从效率来说，everysec模式足够快，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行同步。

3. no
   从安全性来说，no模式下，如果出现故障停机，数据库会丢失上次同步AOF文件之后的所有写命令数据，具有不确定性，因为服务器在每个事件循环都要将AOF缓冲区中的所有内容写入到AOF文件，至于何时对AOF文件进行同步，则由操作系统控制。
   从效率来说，no模式和everysec模式的效率差不多。

   **AOF重写**

   因为AOF持久化是通过保存被执行的写命令来记录数据库数据的，所以随着Redis服务器运行时间的增加，AOF文件中的内容会越来越多，文件的体积会越来越大。Redis提供了AOF文件重写功能，即Redis服务器会创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库数据相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小很多。

**AOF和RDB对比：**

1. 实现方式   快照 vs 命令
2. 文件体积   aof>rdb
3. 安全性       aof>rdb
4. 优先级       aof>rdb

### 分布式

#### 1.分布式环境下生成唯一id

雪花算法：64位long包含 时间戳+机器编号+序列号

可以保证每秒钟，每台机器能产生 序列号长度那么多的不同id



#### 2.Redis分布式锁，redlock

https://zhuanlan.zhihu.com/p/374732293?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

https://zhuanlan.zhihu.com/p/418268774?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

redis分布式锁实现注意事项：

回答：Redis实现分布式锁主要利用Redis的`setnx`命令。`setnx`是`SET if not exists`(如果不存在，则 SET)的简写。

为了保证分布式锁的可用性，至少要确保锁的实现要同时满足以下几点：

- 互斥性。在任何时刻，保证只有一个客户端持有锁。

- 不能出现死锁。如果在一个客户端持有锁的期间，这个客户端崩溃了，也要保证后续的其他客户端可以上锁。

- 保证上锁和解锁都是同一个客户端。

  key是所有线程都一样的，value是不同的请求不一样

  实现流程：1.setnx试图获取锁

  ​                   2.获取锁后执行业务

  ​                   3.执行完业务后释放锁，释放锁前验证value是不是自己设置的

注意点：1.为防止某线程持有锁期间挂掉，key需要设置过期时间，不然就死锁了

​                       过期时间一定要大于业务时间，不然还没执行完就释放了, 

​						或者定期续约，增加expire的时间

​               2. 如何实现可重入锁？ 在setnx的基础上，用一个hash结构记录这个锁的重入次数。

​                  每次释放锁，重入次数-1，知道最后一次，真正释放锁的key。

​                  为了保证操作的原子性，用lua脚本执行枷锁和解锁

​				3. 粗糙的设计是，获取锁失败之后轮询，但是这样太耗费资源了。

​					用发布订阅模式优化：

​					当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。

​					当持有锁的客户端释放锁的时候，发布锁释放的消息。

​					当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。

redlock原理：

#### 3. 一致性hash算法

https://blog.csdn.net/qq_33945246/article/details/105113417

是什么：使请求hash分配到多个节点，并且在节点增加或者减少时，能使大多数原本的请求命中相同的节点

怎么做：hash环+虚拟节点+请求hash映射到环上后顺时针查找

#### 4. 分布式事务：

1.分布式事务的原理,优缺点,如何使用分布式事务,2pc 3pc 的区别,解决了哪些问题,还有哪些问题没解决,如何解决,你自己项目里涉及到分布式事务是怎么处理的.



### 设计模式

#### 1.你在工作中用过哪些设计模式？

单例模式

工厂模式

模板方法模式

装饰模式

代理模式

门面模式



### 其他

1. rpc的流程，原理，需要解决什么问题

   https://zhuanlan.zhihu.com/p/391186905

2. 开发中的设计原则，比如开闭原则

3. mybatis底层原理

   https://www.zhihu.com/question/25007334/answer/2029576882?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_content=group1_Answer&utm_campaign=shareopn

4. ###### 接口幂等性如何实现

   https://zhuanlan.zhihu.com/p/127169053?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

   https://zhuanlan.zhihu.com/p/101274125?utm_source=wechat_session&utm_medium=social&utm_oi=1177322067044765696&utm_campaign=shareopn

   思路：为需要保证幂等性的每一次请求创建一个唯一标识token, 先获取token, 并将此token存入redis, 请求接口时, 将此token放到header或者作为请求参数请求接口, 后端接口判断redis中是否存在此token:

   - 如果存在, 正常处理业务逻辑, 并从redis中删除此token, 那么, 如果是重复请求, 由于token已被删除, 则不能通过校验, 返回请勿重复操作提示
   - 如果不存在, 说明参数不合法或者是重复请求, 返回提示即可

5. 如何设计一个秒杀系统

6. 设计一个短域名服务需要考虑哪些点？

   https://zhuanlan.zhihu.com/p/428419610

   1.如何生成唯一的全局id作为短域名的一部分？

   ① mysql自增主键，②redis的value incry by ③雪花算法

   2.太长了怎么办？

   压缩域名，用0-9 A-Z a-z 62进制

   3.访问短连接如何转到对于的长链接？

   通过数据库和redis存储的数据，用短链接查出长链接，然后重定向到长链接！

​       4.怎么抗住高并发？

​		①合理使用redis缓存取长链接数据 ②用布隆过滤器过滤请求，无效的短链接无法进入后面
